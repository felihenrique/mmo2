Como lidarei com o problema do broadcast para players em excesso
scheduler:
- responsável por criar novas salas de jogo
- cada sala será um container docker
- players numa mesma party só podem entrar na mesma sala
- para salas do tipo shard (mapas do jogo), há um limite de jogadores (inicialmente 50)
- quando um jogador tenta entrar no shard e ele atingiu o limite de jogadores, um novo shard
é criado e o jogador é autorizado a entrar nesse

shard: 
- Haverá um novo serviço chamado scheduler
- Ele será responsável pela troca de players entre regiões
- O jogador pedirá entrar na região x
- O scheduler verificará o tamanho da party. Caso a capacidade atual 

FAZENDO: escrever e ler o tamanho da mensagem

TODO: lista de espera para acessar mundo, com prioridade 
TODO: desconectar player por inatividade
TODO: calcular automaticamente o ping de cada jogador 
TODO: add a opção de adicionar um authenticator para as conexões
  O authenticator será uma interface com a função Authenticate. O pacote gsp
  terá uma função para criar um authenticator baseado em um ip range.
  - Para serviços internos o remote ip precisa estar no range da rede
  - Para conexões externas (players), será preciso verificar no auth server
    se o jogador está autenticado. 
TODO: implementar o sistema de permissões baseado em hierarquia. Por exemplo,
      os jogadores tem permissões x, o community manager tem x + y, o admin x + y + z
TODO: pesquisar sobre social aspect games. algo que trouxe muitas reclamações no hearthwood
TODO: começar a implementar a movimentação dos personagens
TODO: disconnectar o client em caso de flood de pacotes
TODO: decidir o que fazer quando o packet tem outra struct dentro

- Eventos (por ex. jogador conectado, jogador desconectado, jogador no campo de visao, jogador)
  - Ack Input
  - Input Move
  - Jogador conectado
  - Jogador desconectado
  - Jogador movimentou
  - Jogador iniciou cast skill
  - Jogador finalizou cast skill
  - Jogador recebeu dano
  - 

MUSICA TITLE SCREEN: https://opengameart.org/content/grassy-world-overture-8bitorchestral
CIDADE DESERTO: https://opengameart.org/content/fantasy-music-the-eternal-sand
https://opengameart.org/content/desert-theme-1
https://opengameart.org/users/projecthelmet
https://opengameart.org/content/epic-boss-theme
https://opengameart.org/users/hitctrl

Os primeiros minutos de um jogo são os mais importantes. É naquele momento que você irá prender a atenção do jogador e torna-lo interessado em continuar explorando o jogo, ou ele apenas irá fechar o jogo e ver o próximo. 
Outro aspecto importante dos jogos online é a capacidade de reter jogadores por longos períodos. Para que isso seja possível, primeiramente o jogo deve ser divertido de jogar. Outra maneira é investir bastante no aspecto social do jogo, pois muitos jogadores acabam chamando seus amigos para jogar junto. 
Uma boa maneira de icentivar a interação entre jogadores são dungeons que precisam ser feitas em grupo. Podem ser adicionadas dungeons que podem ser feitas diariamente que dão recompensas essenciais para o progresso no jogo.

A ideia do mundo é que seja o mais vivo possível:
- NPCs se movimentando e parecendo que estão cuidando dos próprios negócios.
- Animais se movimentando e interagindo com o ambiente
- Rios em movimento
- Cachoeiras
- Arvores / grama se mexendo com o vento
- Sons ambiente de passaros para a floresta, grilos para a noite.
- Ciclo dia / noite, com cidades acendendo a iluminação durante a noite e com os spawns dos
montros mudando fora da cidade.
- Eventos que mudam como o mundo funciona (por exemplo invasões de monstros)
- World bosses que aparecem de maneira recorrente
- Players/animais que deixam seus corpos no chão ao morrerem (estilo tibia)
TODO: ver pq o grid está com espaçamento entre os itens sem eu ter colocado
TODO: Trackear quantas mensagens tem no buffer da conexão, e caso seja muito alta (definir)
desconectar o jogador para evitar consumo exagerado de memória.
TODO: Criar estrutura chamada BinaryPack que acomoda uma lista de ISerializables.
Checar por esse tipo na função read/write.
TODO: Implementar rate limit para o cliente. Caso passar o rate limit, desconectar o jogador
TODO: evitar que um packet mal formado do cliente crashe o servidor (fazer o recover funcionar)
No read do serialization verificar se a quantidade de bytes é suficiente, caso não seja,
retornar ErrMalformed. Checar também se o tamanho do packet ultrapassa um tamanho x, caso
ultrapasse, retornar ErrMaxSize, e descartar os x bytes do buffer.

https://community.hetzner.com/tutorials/game-server-ddos-protection
Conf. de segurança

TODO: implementar a filtragem dos systems com bitmasks
(ex: mask >> 6 (id do typexxxx). se 1, contem o componente). Dessa maneira a checagem se torna O(n) ao invés de O(n2)
ONDE PAREI:
  - Entidades não estão sendo enviadas ao se conectar
  - O segundo cliente crasha quando o outro se movimenta
  - Quando receber a resposta do servidor sobre o movimento, corrigir o moveTo
    do cliente com os valores calculados pelo servidor